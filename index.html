<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simplify Biarri Splicing Tool</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/FileSaver.js/2.0.5/FileSaver.min.js"></script>

    <style>
  body {
    font-family: Arial, sans-serif;
    max-width: 900px;
    margin: 20px auto;
    padding: 10px;
  }
  textarea {
    width: 100%;
    height: 150px;
    margin-bottom: 10px;
    font-family: monospace;
  }
  button {
    padding: 10px 20px;
    font-size: 16px;
    margin-right: 10px;
  }
  pre {
    background: #f0f0f0;
    padding: 10px;
    white-space: pre-wrap;
  }
</style>
    
</head>
<body>
    <h2>Simplify Biarri Splicing Detail</h2>
    <table style="width: 100%;">
    <!-- Step 1 -->
    <tbody id="step1">
        <tr>
            <td colspan="2"><h2>Step 1: Upload ZIP File Containing CSVs</h2></td>
        </tr>
        <tr>
            <td style="text-align: right;" colspan="2">
                 <a href="splicing conversion.html" style="text-decoration: none; padding: 8px 12px; background-color: #51ff00; color: rgb(104, 104, 104); border-radius: 5px;">Splicing Conversion Tool</a>
                <a href="Tombstone Formatting Tool.html" style="text-decoration: none; padding: 8px 12px; background-color: #ffe600; color: rgb(107, 107, 107); border-radius: 5px;">Tombstone Formatting Tool</a>
                <a href="Direction Tool.html" style="text-decoration: none; padding: 8px 12px; background-color: #ff0000; color: rgb(255, 255, 255); border-radius: 5px;">Direction Tool</a>
            </td>          
        </tr>
        <tr>
            <td><input type="file" id="zipFileInput" accept=".zip" onchange="processAndConvertZip()" /></td>
        </tr>
    </tbody>

    <!-- Step 2 -->
    <tbody id="step2" style="display: none;">
        <tr>
            <td colspan="1"><h3>Input:</h3></td>
        </tr>
        <tr>
            <td style="text-align: center;" colspan="2">
                <textarea id="inputText" placeholder="Paste your big input text here"></textarea>
            </td>
        </tr>
        <tr>
            <td colspan="1"><h3>Reference (optional)</h3></td>
        </tr>
        <tr>
            <td style="text-align: center;" colspan="2">
                <textarea id="referenceText" placeholder="e.g. 288 GP02-14-FOC01(F1-CABLE-0001)"></textarea>
            </td>
        </tr>
        <tr>
            <td>
                <button onclick="convertText()" style="text-decoration: none; padding: 2px 12px; background-color: #ff4bd8; color: white; border-radius: 5px;">Convert</button>
                
            </td>
        </tr>
        <tr>
            <td style="text-align: right;" colspan="2">
                <a href="splicing conversion.html" style="text-decoration: none; padding: 8px 12px; background-color: #51ff00; color: rgb(104, 104, 104); border-radius: 5px;">Splicing Conversion Tool</a>
                <a href="Tombstone Formatting Tool.html" style="text-decoration: none; padding: 8px 12px; background-color: #ffe600; color: rgb(107, 107, 107); border-radius: 5px;">Tombstone Formatting Tool</a>
                <a href="Direction Tool.html" style="text-decoration: none; padding: 8px 12px; background-color: #ff0000; color: rgb(255, 255, 255); border-radius: 5px;">Direction Tool</a>
            </td>          
        </tr>
    </tbody>

    <!-- Output Section -->
    <tr>
        <td colspan="2"><h2>Output</h2></td>
    </tr>
    <tr>
        <td colspan="2"><div id="output"></div></td>
    </tr>
</table>

    <!-- Add this in your HTML head or before your script -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
    <script>
        let processedFiles = {};
        let geoJsonFeatures = [];

        function showStep2() {
            document.getElementById("step1").style.display = "none";
            document.getElementById("step2").style.display = "table-row-group"; 
        }

        async function processAndConvertZip() {
    const fileInput = document.getElementById("zipFileInput");
    if (!fileInput.files.length) {
        alert("Please upload a ZIP file.");
        return;
    }

    const zip = new JSZip();
    const zipFile = fileInput.files[0];
    const zipData = await zip.loadAsync(zipFile);

    let csvFiles = [];

    // ðŸ”¹ Step 1: Process CSV files (instead of writing ZIP to disk)
    for (let fileName in zipData.files) {
        if (fileName.endsWith(".csv")) {
            let csvText = await zipData.files[fileName].async("text");
            let cleanedFileName = fileName.replace(/^splices_/, "").replace(/\.[^/.]+$/, "");
            let processedCSV = processCSV(csvText, cleanedFileName); // your existing logic

            // push into csvFiles array for Step 2
            csvFiles.push({ name: cleanedFileName + ".csv", data: processedCSV });
        }
    }

    // ðŸ”¹ Step 2: Convert processed CSVs â†’ GeoJSON â†’ Excel
    convertToGeoJSON(csvFiles);
    displayOutput();
    downloadExcel();  // auto download Excel
    // âœ… After Excel is downloaded, switch UI to Step 2
    setTimeout(showStep2, 2000); // give download a moment
}



        function processCSV(csvText, fileName) {
            const lines = csvText.split("\n").map(line => line.trim()).filter(line => line);
            if (lines.length < 2) return "Invalid CSV format.";

            let headers = lines[0].split(",").map(header => header.trim());
            const typeIndex = headers.indexOf("type");
            const tierOut = headers.indexOf("tier_out");
                const fibreInIndex = headers.indexOf("fibre_in");
                const fibreOutIndex = headers.indexOf("fibre_out");
                const cableInIndex = headers.indexOf("cable_in");
                const cableOutIndex = headers.indexOf("cable_out");

            if (typeIndex === -1) return "CSV must contain a 'type' column.";

            let processedRows = [];
            processedRows.push(fileName); // Add headers

            for (let i = 1; i < lines.length; i++) {
                let row = lines[i].split(",").map(value => value.trim());
                const typeValue = row[typeIndex]?.toLowerCase();
                const tierValue = row[tierOut]?.toLowerCase();
                if (typeValue !== "dead" && typeValue !== "spare" && tierOut !== "dedicated_cable") {
                    let fibreIn = fibreInIndex !== -1 && !isNaN(row[fibreInIndex]) && row[fibreInIndex] !== ""
                            ? "F" + row[fibreInIndex] 
                            : "";
                        let fibreOut = fibreOutIndex !== -1 && !isNaN(row[fibreOutIndex]) && row[fibreOutIndex] !== ""
                            ? "F" + row[fibreOutIndex] 
                            : "";
        
                        let cableInFibre = row[cableInIndex].replace("F1_cable", "").trim() + (fibreIn ? " " + fibreIn : "");
                        let cableOutFibre = row[cableOutIndex].replace("F1_cable", "").trim() + (fibreOut ? " " + fibreOut : "");

                        let additionalInfo = row[typeIndex]; // Default to original value
                        if (/F1-CABLE/.test(cableInFibre) && /F2-CABLE/.test(cableOutFibre) && typeValue === "split") {
                            additionalInfo = "PSsplit";
                        } else if (/F2-CABLE/.test(cableInFibre) && /F3-CABLE/.test(cableOutFibre) && typeValue === "split") {
                            additionalInfo = "SSsplit";
                        }
                    processedRows.push(`${cableInFibre},${additionalInfo},${cableOutFibre}`);
                }
            }
            return processedRows.join("\n");
        }

        function downloadProcessedZip() {
            const zip = new JSZip();
            for (let fileName in processedFiles) {
                zip.file(fileName, processedFiles[fileName]);
            }

            zip.generateAsync({ type: "blob" }).then(blob => {
                saveAs(blob, "processed_csvs.zip");
                setTimeout(() => {
                    alert("âœ… Processed ZIP file has been downloaded successfully!");
                }, 1500); // Ensures alert appears AFTER the file download
            });
        }

        /*async function processGeoJsonZip() {
            const fileInput = document.getElementById("geoJsonZipInput");
            if (!fileInput.files.length) {
                alert("Please upload the processed ZIP file.");
                return;
            }

            const zip = new JSZip();
            const zipFile = fileInput.files[0];
            const zipData = await zip.loadAsync(zipFile);
            geoJsonFeatures = [];

            let csvFiles = [];

            // ðŸ”¹ Read all CSVs from ZIP
            for (let fileName in zipData.files) {
                if (fileName.endsWith(".csv")) {
                    let csvText = await zipData.files[fileName].async("text");
                    csvFiles.push({ name: fileName, data: csvText });
                }
            }

            // ðŸ”¹ Convert CSV â†’ GeoJSON features
            convertToGeoJSON(csvFiles);

            // ðŸ”¹ Show preview in page
            displayOutput();

            // ðŸ”¹ Auto-download Excel
            downloadExcel();
        }*/

function convertToGeoJSON(csvFiles) {
    geoJsonFeatures = [];

    csvFiles.forEach(file => {
        const lines = file.data.split('\n');
        if (lines.length < 2) return;

        // use filename (without extension) as hubName
        const hubName = file.name.replace(/\.[^/.]+$/, "");
        let formattedStrings = [];

        for (let i = 1; i < lines.length; i++) {
            const line = lines[i].split(',');
            if (line.length < 3) continue;

            const inCable = line[0].trim();
            const type = line[1].trim();
            const outCable = line[2].trim();

            if (inCable.toUpperCase() === 'DEAD' || outCable.toUpperCase() === 'DEAD' || 
                inCable.toUpperCase() === 'SPARE' || outCable.toUpperCase() === 'SPARE') {
                continue;
            }

            const formattedString = `In ${inCable} ${type} ${outCable}`;
            formattedStrings.push(formattedString);
        }

        if (formattedStrings.length > 0) {
            const connectionsStr = formattedStrings.join(', ');
            const feature = {
                type: "Feature",
                properties: {
                    hubName: hubName,
                    connections: connectionsStr,
                    Comb: hubName + "/" + connectionsStr + ">"
                },
                geometry: { type: "Point", coordinates: [0, 0] }
            };
            geoJsonFeatures.push(feature);
        }
    });
}

function downloadExcel() {
    if (geoJsonFeatures.length === 0) {
        alert("No data to export.");
        return;
    }

    // Build rows for Excel
    let rows = geoJsonFeatures.map(feature => ({
        Hub: feature.properties.hubName,
        Connections: feature.properties.connections,
        Comb: feature.properties.Comb
    }));

    // Convert JSON â†’ worksheet
    const worksheet = XLSX.utils.json_to_sheet(rows);

    // Create workbook and append worksheet
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Connections");

    // Save file immediately
    XLSX.writeFile(workbook, "data.xlsx");

    setTimeout(() => {
        alert("âœ… Processed ZIP file has been converted and downloaded as Excel!");
        alert("ðŸš€ Launching to Tombstone Formatting Tool.html!");
        window.location.href = "Tombstone Formatting Tool.html";
    }, 1000);
}


//2nd tool finish


        function displayOutput() {
            let outputDiv = document.getElementById("output");
            outputDiv.innerHTML = "";

             // Display processed CSV files
            for (let fileName in processedFiles) {
                let pre = document.createElement("pre");
                pre.textContent = `File: ${fileName}\n${processedFiles[fileName]}`;
                outputDiv.appendChild(pre);
            }                               

            if (geoJsonFeatures.length > 0) {
                let geoJsonContainer = document.createElement("div");
                geoJsonContainer.style.border = "1px solid #ddd";
                geoJsonContainer.style.padding = "10px";
                geoJsonContainer.style.marginTop = "20px";
                geoJsonContainer.style.overflowX = "auto";
        
                let geoJsonTitle = document.createElement("h3");
                geoJsonTitle.textContent = "Converted GeoJSON (Hub & Connections):";
                geoJsonContainer.appendChild(geoJsonTitle);
        
                geoJsonFeatures.forEach(feature => {
                    let hubInfo = document.createElement("p");
                    hubInfo.innerHTML = `<strong>${feature.properties.hubName}:</strong> ${feature.properties.connections}`;
                    hubInfo.style.marginBottom = "5px";
                    geoJsonContainer.appendChild(hubInfo);
                });
                outputDiv.innerHTML = "";
                outputDiv.appendChild(geoJsonContainer);
            }
        }
    </script>
</body>
</html>
